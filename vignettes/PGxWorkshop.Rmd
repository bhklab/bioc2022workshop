---
title: "Pharmacogenomic Analysis of Drug Combination Experiments to Identify
  Biomarkers of Response or Resistance"
author:
  - name: Christopher Eeles
    email: christopher.eeles@uhnresearch.ca
    affiliation:
        - &pm Princess Margaret Cancer Centre
  - name: Petr Smirnov
    email: petr.smirnov@utoronto.ca
    affiliation:
        - *pm
        - &uot University of Toronto
output: BiocStyle::html_document
bibliography: BioC2022Conference.bib
vignette: >
  %\VignetteIndexEntry{Pharmacogenomic Analysis of Drug Combination Experiments to Identify Biomarkers of Response or Resistance}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- Remove {-} from header to show numbering -->
# Workshop Overview {-}

## Instructor(s) name(s) and contact information {-}

* Christopher Eeles <christopher.eeles@uhnresearch.ca>
* Petr Smirnov <petr.smirnov@utoronto.ca>
* Benjamin Haibe-Kains <benjamin.haibe.kains@utoronto.ca>

## Workshop Description {-}

<!-- Alias package links -->
```{r eval=TRUE, echo=FALSE}
PGx <- BiocStyle::Biocpkg("PharmacoGx")
CGx <- BiocStyle::Biocpkg("CoreGx")
TGx <- BiocStyle::Biocpkg("ToxicoGx")
RGx <- BiocStyle::Biocpkg("RadioGx")
Xv <- BiocStyle::Biocpkg("Xeva")
DT <- BiocStyle::CRANpkg("data.table")
SE <- BiocStyle::Biocpkg("SummarizedExperiment")
MAE <- BiocStyle::Biocpkg("MultiAssayExperiment")
```

This workshop will introduce users to the `r CGx` and
`r PGx` R packages, which are useful tools for
pharmacogenomic modelling to discover biomarkers of treatment response in cancer
model systems. `r PGx` specifically focuses on
drug sensitivity experiments in cancer cell lines, which will be the major
focus of this workshop. Additional infrastructure from our lab includes
`r TGx` for toxicogenomics in healthy human
cell-lines, `r RGx` for
radiogenomics in cancer cell-lines and `r Xv` for
pharmacogenomics in patient derived xenograph (PDX) murine models.

Participants will learn the fundamentals of using `r CGx`
and `r PGx` to create a `PharmacoSet`&mdash;an
integrative container for the storage, analysis and visualization of
pharmacogenomic experiments. Particular focus will be placed
on newly developed support for storing, analyzing and visualizing drug
combination sensitivity experiments and correlating results therefrom for
with multi-omic molecular profiles to discover biomarkers of drug senstivity
or resistance.

### Pre-requisites {-}
  * Basic knowledge of R syntax
  * Knowledge of or interest in pharmacogenomics
  * Familiarity with core Bioconductor classes such as the
  and `r SE` and `r MAE`
  * Curiosity about or experience with `r DT` an assest!


Useful publications:

* Smirnov, P., Safikhani, Z., El-Hachem, N., Wang, D., She, A., Olsen, C., Freeman, M., Selby, H., Gendoo, D. M. A., Grossmann, P., Beck, A. H., Aerts, H. J. W. L., Lupien, M., Goldenberg, A., & Haibe-Kains, B. (2016). PharmacoGx: An R package for analysis of large pharmacogenomic datasets. Bioinformatics (Oxford, England), 32(8), 1244–1246. https://doi.org/10.1093/bioinformatics/btv723
* Tonekaboni, M., Ali, S., Soltan Ghoraie, L., Manem, V. S. K. & Haibe-Kains, B. Predictive approaches for drug combination discovery in cancer. Brief Bioinform 19, 263–276 (2018).



### Workshop Participation {-}

<!-- The workshop will be presented as a set of analysis steps to be replicated by the learners, with instructors
available to explain the why and how of applying these functions to the given datasets. Learners will write analysis
scripts as well as use interactive commands to explore the generated data structures and results. Learners will then
brainstorm potential applications of the analysis results in their field as well as comment on use case examples
presented by the instructors on research in our lab. -->


Participants expected to have the following required packages installed on their
machines to be able to run the commands along with the instructors:


### _R_ / _Bioconductor_ packages used {-}

Bioconductor:

* `r CGx`
* `r PGx`

CRAN:

* `r DT`

## Time outline {-}

For a 1.5-hr workshop:

| Activity                                                   | Time |
|------------------------------------------------------------|------|
| Introduction to CoreGx and PharmacoGx                      |  5m  |
| Overview of Data Structures                                |  15m |
| How TRE Support Drug Combinations Data Analysis            |  10m |
| Using Data Mapper to build a Drug Combo PharmacoSet.       |  10m |
| Dose Response Models and Drug Sensitivity measures         |  10m |
| Drug Combination Synergy Models                            |  10m |
| Biomarker Discovery                                        |  15m |
| Introduction to Resources for Biomarker Validation         |  5m  |


## Workshop goals and objectives {-}

### Learning goals {-}

* Describe pharmacogenomic mono and combination datasets and usefulness in cancer research
* Understand how experimental designs and research questions map onto data structures
* Learn how to extract information from these datasets
* Learn how to visualize experimental results from these datasets
* Learn how to model dose-response for both monotherapy and combination small compound datasets
* Learn measures to quantify response and synergy in cell line sensitivity screens

### Learning objectives {-}

* List available standardized pharmacogenomic and radiogenomic datasets and download them
* Access the molecular features, dose-response and metadata contained within the data structures defined in the packages
* Fit Hill Slope models to dose-response experiments using small compound treatments in cell lines
* Calculate the AAC, AUC, IC50 metrics for response quantification in cell lines
* Predict in vitro univariate biomarkers for drug response and drug synergy using the PharmacoGx


----

```{r load_packages, eval=TRUE, echo=FALSE, include=FALSE}
suppressPackageStartupMessages({
    library(pgxBioc2022Workshop)
    library(PharmacoGx)
    library(data.table)
    library(ggplot2)
})
```

# Introduction to CoreGx and PharmacoGx

This tutorial, titled Pharmacogenomic Analysis of Drug Combination Experiments
to Identify Biomarkers of Response or Resistance, focuses on using the
`r PGx` R package to correlate treatment response,
measured as the viability of cancer cell-lines after _in vitro_ drug treatment,
with their respective multi-omic profiles. `r CGx`
provides the core infrastructure for storing, analyzing and visualizing generic
treatment response experiments. It provides functions and classes which can be
inherited in downstream packages, such as `r TGx` and
`r RGx`. We hope that the `CoreSet` object is
generalized enough that it can be reused by other developers for their specific
treatment response use case.

## CoreGx

### CoreSet Class

<!--
{r coreset,  echo=FALSE, fig.wide=TRUE, fig.cap = "**CoreSet class diagram**. Objects comprising a `CoreSet` are enclosed in boxes. The first box indicates the type and name of each object. The second box indicates the structure of an object or class. The third box shows accessor methods from `PharmacoGx` for that specific object. '=>' represents return and specifies what is returned from that item or method."}
knitr::include_graphics("./CoreSetClassDiagram.png")
-->

### Package Nomenclature

To facilitate modularization of the GxSuite of R packages, we are shifting
the nomenclature within a `CoreSet`&ndash;and therefore in inheriting packages
&ndash;to be more general.

To this end, we are making the following changes:

  * Previous reference to cell (cell-line) will become sample, allowing the
`CoreSet` to be used for other model systems
  * Drug (radiation in `RadioGx`) will become treatment, allowing the
`CoreSet` to be treatment type agnostic
  * Sensitivity will become response (sensitivty slot becomes treatmentResponse)

As a result of these changes, the names of some common accessors will be updated.
The old accessors will still remain, ensuring backwards compatibility for at
least two Bioconductor releases. A deprecation warning will be added to old
accessors informing users of the corresponding new function, as per Bioconductor
best practices.

## PharmacoGx

PharmacoGx stores drug screening data together with molecular profiling of
cell lines in an object called a `PharmacoSet`, or `PSet` for short. This object
inherits for the `CoreSet` class defined in our package `CoreGx`, which abstracts
the common functionality across our similar packages.




---

# Overview of Data Structures

The GxSuite of packages make use of various Bioconductor classes for storing
molecular profile data.

## `CoreSet`

__Need to update the class diagram__

## `PharmacoSet`

The basic structure of a PharmacoSet is as follows:

<!--
r pharmacoset, echo=FALSE, fig.wide=TRUE, fig.cap = "**PharmacoSet class diagram**. Objects comprising a `PharmacoSet` are enclosed in boxes. The first box indicates the type and name of each object. The second box indicates the structure of an object or class. The third box shows accessor methods from `PharmacoGx` for that specific object. '=>' represents return and specifies what is returned from that item or method."}
knitr::include_graphics("./PharmacoGxClassDiagram.png")
-->

## `TreatmentResponseExperiment`

```{r tre_class, echo=FALSE, fig.wide=TRUE, fig.cap = " **TreatmentResponseExperiment class diagram**. Objects comprising a `TreatmentResponseExperiment` are enclosed in boxes. The first box indicates the type and name of each object. The second box indicates the structure of an object or class. The third box shows accessor methods from `PharmacoGx` for that specific object. '=>' represents return and specifies what is returned from that item or method."}
knitr::include_graphics("./TreatmentResponseExperimentClassDiagram.drawio.png")
```

```{r tre_structure, echo=FALSE, fig.wide=TRUE, fig.cap="Describe this plot"}
knitr::include_graphics("./TreatmentResponseExperimentStructure.drawio.png")
```

## `MultiAssayExperiment` and `SummarizedExperiment`

The `MultiAssayExperiment` is a common Bioconductor class for storing the results
of diverse mutli-omic data. Along with the `SummarizedExperiment`, this object
is used to store molecular phenotype data in a `CoreSet` and `PharmacoSet`.

```{r SummarizedExperiment_schema, echo=FALSE, fig.wide=TRUE, fit.show="hold", out.width="50%", fig.cap=" `r SE` and `r MAE`"}
knitr::include_graphics("./SummarizedExperiment_schematic.png")
knitr::include_graphics("./MultiAssayExperiment_schematic.png")
```


----

# How the `TRE` Support Drug Combinations Data Analysis

## Drug Combination Experiments

The field of precision oncology is increasingly interested in exploring possible
synergies between cancer therapies. To accelarate the process of translating
insights from _in vitro_ drug combination experiments into clinical
practice, we have extended the `CoreSet` and `PharmacoSet` classes with a new
object, the `TreatmentResponseExperiment` (`TRE`), which has been specifically
designed to handle high dimensional biological stimilus response data.
While drug combinations are the first use case for this data structure,
as cancer model systems continue to advance we expected to also see sample-wise
combinations. For example, 3D organoid models could include multiple cell-lines
or patient tissue types.

## Building A Drug Combination PharmacoSet

### `DataMapper` Class

The `DataMapper` is an abstract class included in `CoreGx` where it can be used
to store metadata specifying a "recipe" to go from raw data files associated
with a specific experiment or publication and a curated, standardize data
format specified as an R `S4` class.

In `r CGx` we have implemented the `TREDataMapper` class, which encodes how
the rawdata from a drug combination experiment should be transformed
into its associated `TRE` object. A primary motivation for the creation of this
class was to document and standardize creation of `TRE` objects from the myriad
experimental designs available in drug combination experiments in the wild. It
is our hope that, for example, 3x3 drug combination experiments have enough in
common that we could theoretically create a `3by3TREDataMapper` which works
for (almost) all publications following this design.

As things stand right now, the `TREDataMapper` primarily acts as helper class
to explore the specifics of a drug combination experimental design. It allows
us to generate hypotheses about which identifiers are required to identify
observations in an assay. Below we will see how, along with the `guessMapping`
method, we can use the `TREDataMapper` to ensure we have mapped all data
from the NCI-ALMANAC drug combination experiment into a `TRE` object, ensuring
that the all study experiments and relevant metadata are captured in our
`TRE` and therefore in our `PharmacoSet`.

By curating and releasing such `PharmacoSet` objects, we ensure that our users
can access all information from the original publication via `r PGx` and therefore
easily ensure the reproducbility of the results as well as compare them against
any other `PharmacoSet` object we have curated. By doing so, we help to improve
the reproducbility and consistency of _in-vitro_ pharmacogenomic experiments
and accelerate the translation from the lab to the clinic.

### Using the `TREDataMapper` to Construct a `TreatmentResponseExperiment`

For this workshop we have included a subset of the NCI_ALMANAC_2017
`PharmacoSet`, curated from [@holbeck_national_2017]. When approaching new
treament response experiment data, the first step is to merge it into a single,
long format table. We have done this already and included it as the
`NCI_ALMANAC_raw` dataset in the workshop package.

```{r nci_rawdata_echo, eval=FALSE, echo=TRUE}
data(NCI_ALMANAC_raw)
(head(NCI_ALMANAC_raw))
```

```{r nci_rawdata_eval, eval=TRUE, echo=FALSE}
data(NCI_ALMANAC_raw)
knitr::kable(head(NCI_ALMANAC_raw, 5))
```

Viewing the table, we see that each column represents a variable, and that
the number of rows in the table corresponds to the number of dose-response
observations measured in the `NCI-ALMANAC` study. To those familiar with
the `tidyverse`, you may recognize that this dataset is in
[tidy format](https://r4ds.had.co.nz/tidy-data.html). It is also said be
in a "long" format because all observations are contained in a single column,
contrast this with a "wide" format where columns
In order for the helper
methods of the `TREDataMapper` class to work, our rawdata must first be in
a single large, tidy `data.frame` or `data.table`.

Since these conditions are met, we can create of `TREDataMapper` object and
start exploring the to dimensionality of our data!

```{r data_mapper_creation, eval=TRUE, echo=TRUE}
(treDataMapper <- TREDataMapper(rawdata=NCI_ALMANAC_raw))
```

A `DataMapper` as a concept is simply a collection of metadata around our
rawdata which defines how different columns map to different aspects of our
target `S4` class. For a `TRE`, similar to a `r SE`, we have the concept of
`rowData` which defines what is considered a treatment
(a specific drug combination experiment) and `colData` which defines what is
considered a sample (a specific cell-line and possible biological replicate
identifier).

The `guessMapping` method can be used to test our hypothesis about which
information maps to treatments (rows), samples (columns) or assays
(experimental observations).

For our first guess, lets assume there are no replicates and see if we are
able to map all of our rawdata columns using just treatment, treatment dose
and sample identifiers.

```{r data_mapper_incorrect_guess, eval=TRUE, echo=TRUE}
groups1 <- list(
    rowDataMap=c("treatment1id", "treatment2id", "treatment1dose",
        "treatment2dose"),
    colDataMap=c("sampleid"),
    assayMap=c("treatment1id", "treatment2id", "treatment1dose",
        "treatment2dose", "sampleid"
    )
)

(guess1 <- guessMapping(treDataMapper, groups=groups1, subset=TRUE))
```

Observing the results of our first guess, we can see that many column remain
unmapped. This likely indicates there is an additional piece of information
needed to uniquely identify the dimensions of our drug combination experiment
data. One potential cause for such cases in inclusion of technical or biological
replicates.

Indeed, for the NCI-ALMANAC both of these kinds of replicates are present.

```{r debugging_incorrect_guess, eval=TRUE, echo=TRUE}
str(rawdata(treDataMapper), give.attr=FALSE)
```

Examining the columns in the data, we see we have already defined the columns
`bio_rep` and `tech_rep` to the raw data in preprocessing. For your own data
in the wild, you will likely need to consult the original publication and
explore the data to differential these two types of replicates and assign
identifiers to which differentiate every unique observation within an
experiment.

```{r data_mapper_correct_guess, eval=TRUE, echo=TRUE}
groups2 <- list(
    rowDataMap=c("treatment1id", "treatment2id", "treatment1dose",
        "treatment2dose", "tech_rep"),
    colDataMap=c("sampleid", "bio_rep"),
    assayMap=c("treatment1id", "treatment2id", "treatment1dose",
        "treatment2dose",  "sampleid", "bio_rep", "tech_rep")
)

(guess2 <- guessMapping(treDataMapper, groups=groups2, subset=TRUE))
```

Since we no long have any unmapped columns, we know that we have found
valid dimension identifiers for our data. It is possible that some datasets
will have multiple valid dimension definitions, so further exploration may
be required if the first solution doesn't fit with your domain knowledge of the
experiment or with the design of the `TRE`.

Lets assign our mapped columns back to the `TREDataMapper` so we can use
it to construct a `TreatmentResponseExperiment`.

```{r updating_the_data_mapper, eval=TRUE, echo=TRUE}
metadataMap(treDataMapper) <- list(experiment_metadata=guess2$metadata$mapped_columns)
rowDataMap(treDataMapper) <- guess2$rowDataMap
colDataMap(treDataMapper) <- guess2$colDataMap
```

Unless we wish to have a single large assay in our `TRE`, we should further
subdivide our assay columns into sensible groups.

```{r splitting_up_the_assays1}
(guess2$assayMap)
```

For the NCI-ALMANAC we have decided to separate our treatment-response
measurements into the "response" assay. Any additional metadata which doesn't
map cleaning to rows or columns gets assigned to "assay_metadata". We
setup a nested list where each item defines an assay in the `TRE`, with the
"id_columns" containing identifiers needed to uniquely map each row in an
assay to its associated treatments and samples. The "mapped_columns" item
specifies the definition of the assay table.

```{r splitting_up_the_assays2}
assaymap <- list(
    response=list(
        id_columns=guess2$assayMap$id_columns,
        mapped_columns=c("viability", "PERCENTGROWTH", "PERCENTGROWTHNOTZ",
            "EXPECTEDGROWTH", "TESTVALUE", "CONTROLVALUE", "TZVALUE")
    ),
    profiles=list(
        id_columns=guess2$assayMap$id_columns,
        mapped_columns=c("SCORE")
    ),
    assay_metadata=list(
        id_columns=guess2$assayMap$id_columns,
        mapped_columns=c("COMBODRUGSEQ", "STUDY", "TESTDATE", "PLATE",
            "SCREENER", "PREFIX2", "CONCINDEX1", "CONCINDEX2", "SAMPLE1",
            "SAMPLE2")
    )
)
assayMap(treDataMapper) <- assaymap
(treDataMapper)
```

Now that we have assigned all the necessaru metadata to the `TREDataMapper`,
creating the object is as simple as calling `metaConstruct`, which combines
together the rawdata and the metadata into a constructo call for the
`TreatmentResponseExperiment`.

```{r metaconstruct_tre}
(NCI_ALMANAC_tre <- metaConstruct(treDataMapper))
```

### Combining with Omics Data into a `PharmacoSet`

The NCI-ALMANAC study did not conduct its own step of molecular profiling
experiments, since the NCI60 experiment already profiled all cell-lines
available in the NCI-ALMANAC. Since we have already curated a `PharmacoSet`
for `NCI60`, adding our molecular data to the NCI-ALMANAC `PharmacoSet`
requires no manual curation.

```{r load_molecular_data}
data(NCI60_molecular_data)
(NCI60_molecular_data)
```

We can see the molecular data is available as `MultiAssayExperiment` containing
four `RangedSummarizedExperiment` objects. The molecular data types are:
  1. "rna" represents RNA expression microarray data.
  2. "mirna" represents microRNA expression data.
  3. "rnaseq.comp" contains RNA sequencing data.
  4. "rnaseq.iso" is RNA sequencing data specifically targeting transcript isoforms.

Once we have our `MultiAssayExperiment` and `TreatmentResponseExperiment`
objects ready, we simply have to extract and curate sample and treatment
metadata slots which store a summary of available samples and treatments in
our `PharmacoSet` object.

For brevity, we included preassembled annotation files for NCI-ALMANAC since
manual curation is beyong the scope of this workshop. When creating your
own `PharmacoSet`, we recommend assembling a set of standardized annotations
from sources like PubChem or ChEMBL for treatments and Cellosaurus for
cancer cell-lines and using these to standardize identifiers in your data
as well as add links to the entities in external databases so users can
look up additional information if needed.

```{r load_sample_metadata_files1, eval=FALSE}
data(NCI_ALMANAC_sample_metadata)
head(NCI_ALMANAC_sample_metadata)
```

```{r load_sample_metadata_files2, echo=FALSE}
data(NCI_ALMANAC_sample_metadata)
knitr::kable(head(NCI_ALMANAC_sample_metadata))
```

Here the sample metadata is present which will be assigned to the `@sample`
slot of our `PharmacoSet`.

```{r load_treatment_metadata_files1, eval=FALSE}
data(NCI_ALMANAC_treatment_metadata)
head(NCI_ALMANAC_treatment_metadata)
```

```{r load_treatment_metadata_files2, echo=FALSE}
data(NCI_ALMANAC_treatment_metadata)
knitr::kable(head(NCI_ALMANAC_treatment_metadata))
```

The treatment metadata contains useful information such as PubChem cid and


For the curation list, we extract our mappings from our standardized identifiers
to

```{r build_the_curation_list}
curation <- list(
    sample=NCI_ALMANAC_sample_metadata[, c("sampleid", "NCI_ALMANAC.sampleid")],
    treatment=NCI_ALMANAC_treatment_metadata[, c("treatmentid", "NCI_ALMANAC.treatmentid")],
    tissue=data.frame(
        NCI_ALMANAC_sample_metadata[, c("tissueid", "NCI_ALMANAC.disease")],
        rownames=NCI_ALMANAC_sample_metadata$sampleid
    )
)
```

```{r create_our_drug_combo_pharmacoset}
(NCI_ALMANAC_2017 <- PharmacoSet2(
    name="NCI_ALMANAC_2017",
    molecularProfiles=NCI60_molecular_data,
    treatmentResponse=NCI_ALMANAC_tre,
    treatment=NCI_ALMANAC_treatment_metadata,
    sample=NCI_ALMANAC_sample_metadata,
    curation=curation
))
```

----

# Dose Response Models and Drug Sensitivity Measures

Understanding monotherapy dose-viability data is an important step in assessing drug combination response. Drug synergy is assessed by
comparing the observed combination response compared to what is expected from the response of cells to each drug separately. While
different models for "expected" combination effect will be discussed in the next section, we first review how monotherapy data is analyzed.

Monotherapy dose-response experiments are usually analyzed by first fitting a dose-viability model to the observed measurements.
The most common model used in the literature is a form of sigmoid function, called the Hill Curve. The Hill Curve has its
basis in the Michaelis-Menten chemical kinetics model, while adding an extra parameter to account for co-operativity of binding.
To better match real observed data, the model can also be extended to include parameters controlling the maximum and minimum observed
viability.

_NB: Sometimes, dose-viability and dose-response curves are used interchangebly in the literature. Precisely, dose-response curves
for a cell kiling screen would plot % cell death against dose, leading to an increasing sigmoid curve._

In `r PGx`, we use the 3 Parameter Hill Curve
function as our model of drug response in cancer cell lines:

$$y = E_\infty + \frac{1-E_\infty}{1 + (\frac{x}{EC50})^{HS}}$$
This is a log-logistic model, meaning that it takes the form of a logistic curve when x is on the log scale.
The three parameters are:
$E_\infty$, which is the maximal inhibition predicted at infinite concentration of the drug (the right asymptote);
$EC50$, which is the inflection point of the logit, where the inhibition reaches 50% of the maximum;
$HS$, the Hill Slope, which is a measure of the cooperativity of binding. This parameter controls the steepness
of the logit, and is interpreted based on its relation to 1. Values larger than 1 imply positive cooperativity in
inhibition/binding of the target for the small molecule ligands, which values less than 1 imply negative cooperativity/antagonism.



```{r hillSlopeFig, fig.cap="Diagram of a logLogistic Hill Slope", echo=FALSE}
knitr::include_graphics("./hill_slope.png")
```


PharmacoGx provides functions to both fit and visualize dose-viability curves. Plotting dose-viability data is easy using the
`drugDoseResponseCurve` function:


```{r ddrc_own, warning=FALSE}
concentrations <- (1 / 2)^seq(0, 8) * 1
viabilities <- c(0.1, 5, 15, 23.8, 55.2, 85.9, 96.9, 98.4, 99.2)

drugDoseResponseCurve(concentrations = list("Exp 1" = concentrations), viabilities = list("Exp 1" = viabilities), plot.type = "Both")
```

Similarly, fitting Log-Logistic models to data is simple using the `logLogisticRegression` function in `PharmacoGx`.

```{r loglogistic, warning=FALSE}
concentrations <- (1 / 2)^seq(0, 8) * 1
viabilities <- c(0.1, 5, 15, 23.8, 55.2, 85.9, 96.9, 98.4, 99.2)

(pars <- logLogisticRegression(conc = concentrations, viability = viabilities))
```

<!-- `(` always prints its contents, even for assignments. It's cleaner than printing after IMO. -->

Note that sometimes, it is may be more appropriate to use either a 2 parameter model (excluding the $E_\infty$ parameter), or a
4 parameter model, including a parameter for the left-assymptote, that is, the measurement when no drug is added. `PharmacoGx` is opiniated
in using the 3 parameter model, as the logical value for the viability as a percentage of untreated cells when no drug is added is 100%.
However, the `drc` CRAN package provides a larger variety of dose-response models, should it be appropriate in your application.


We will soon demonstrate how to apply the `logLogisticRegression` to dose-viability data stored in a `TreatmentResponseExperiment`,
but first we will talk about how to summarize dose-response curves for downstream analysis.


### Computing Summary Measures for DDRCs

Often with _in vitro_ Pharmacogenomics data, we want to compare the drug sensitivity of a cell line
to some omic features. For this, we want to summarize the drug dose response curve into a single
number representing the sensitivity of the cell line.

```{r hillSlopeSumFig, fig.cap="Some commonly used summary metrics for a dose-response curve", echo=FALSE}
knitr::include_graphics("./hillSlopeSummary.png")
```


The IC50 and Area Above the Curve are two
convenient metrics for quantifying the observed drug sensitivity. If you noticed above,
the `drugDoseResponseCurve` function computes them by default. In PharmacoGx, they can be
computed manually as follows:

```{r sens_ow, warning=FALSE}
concentrations <- 1/2^seq(0,8) * 1
viabilities <- c(0.1, 5, 15, 23.8, 55.2, 85.9, 96.9, 98.4, 99.2)

(PharmacoGx::computeAUC(concentration = concentrations, viability = viabilities))
(PharmacoGx::computeIC50(concentration = concentrations, viability = viabilities))
```

If measurements are passed into these function, the Log Logistic model is fit to compute the IC50 and AAC.
Clearly, if multiple metrics are being computed, redoing the fit is inefficent. Therefore, these functions
can also take parameters fit by `logLogisticRegression`.

```{r sens_own_fit_first, eval=TRUE}
concentrations <- (1 / 2)^seq(0, 8) * 1
viabilities <- c(0.1, 5, 15, 23.8, 55.2, 85.9, 96.9, 98.4, 99.2)
pars <- logLogisticRegression(conc = concentrations, viability = viabilities)

(PharmacoGx::computeAUC(concentration = concentrations, Hill_fit = pars))
(PharmacoGx::computeIC50(concentration = concentrations, Hill_fit = pars))
```


### Processing Monotherapy Data With the TRE

Usually, we will have more than one dose-viability experiment we wish to analyze at a time. Thankfully, the TRE
data class makes it very easy to process large numbers of drug sensitivity experiments at the same time.

For this example, we will subset out the monotherapy experiments in the NCI-Alamanac dataset which we were using
as an example above.


```{r fitting_and_aac_tre}
NCI_tre <- treatmentResponse(NCI_ALMANAC_2017)

## TreatmentResponseExperiment method
NCI_tre |>
    subset(is.na(treatment2dose)) ->
    NCI_mono

```

For the interest of computation time, we will only look at experiments involving Vincristine.
```{r}
## Should we be fitting these replicates separately or together?
NCI_mono |>
  subset(treatment1id == "Vincristine") |>
  assay("response", withDimnames=TRUE) |>
  aggregate(
    by=c("treatment1id", "sampleid", "bio_rep"),
    {
      pars <- logLogisticRegression(treatment1dose, viability = viability)
      auc <- computeAUC(treatment1dose, Hill_fit = pars)
      ic50 <- computeIC50(treatment1dose, Hill_fit = pars)
      list(HS=pars[[1]], Einf=pars[[2]], EC50=pars[[3]], AAC=auc, IC50=ic50)
    },
    enlist=FALSE
  ) ->
  vincristine_monotherapy

```

As you can see, by using the `aggregate` method, we are able to

Once we have values computed in a `data.table`, we can store them back in the Treatment Response Experiment. Notice that the TRE
object handles seemlessly the fact that we have values computed for only a subset of experiments.

```{r}
NCI_mono$vincristine_profiles <- vincristine_monotherapy
NCI_mono$vincristine_profiles[order(sampleid)]
```

Note, while when we print out the assay above, we see many repeated values, these values are only duplicated upon printing and
are not saved as duplicates in memory.



# Drug Combination Synergy Models

When assessing drug combinations, the question of interest is usually not to quantify drug response to the therapy,
but to identify combinations that give more or less response to therapy than expected from the monotherapy regiments,
that is, to look for synergy or antagonism. Alternatively, for a paritcular drug combination, we may be interested to
identify which biological models show synergy or antagonism, and understand why that could be the case on a molecular level.

For these tasks, it is important to define what we expect the result of combining two drugs at a particular combination to
be without the presence of any synergy or antagonism between them. Usually, when searching for synergy,
will have access to experiments testing each drug in monotherapy, as well as the drugs in combination. For our discussion, we
we restrict ourselves to the two-drug combination case, however, the principles we discuss can be extended to handle multiple
drugs.

Unfortunately, there is no consensus of what the theoretical expected value of response for combining two drugs is, given the
response that each drug elicits in monotherapy. However, there are three models widely applied in the literature, each with
different biological assumptions behind them.

To introduce these models, we will define some mathematical notation, which we will use both throughout our exposition and the
example computations. Let $x_{1}$, and $x_{2}$ correspond to the corresponding drug 1 and drug 2 doses at which we wish to predict
the expected combination response. Let $v_{1}$ and $v_{2}$ be the viabilities that are observed in monotherapy for these drugs, and
$v_{c}$ be the viability observed in combination. Furthermore, let $r_{i} = 1 - v_{i}$ be the response value corresponding to each
measured viability. We will use both response and viability measurements in explaining the models, as some are more natural from one
or the other perspective. However, it is easy to convert between these variables using the relationship above.

When we look for drug synergy, we are looking for cases where $v_c < v_{model}$, or $r_c > r_{model}$. The degree of synergy
is usually measured either on the additive or multplicative scale, that is, looking at either $v_c - v_{model}$ or $v_c / v_{model}$.
However, some models, such as the ZIP described below, also perscribe a certain perspective to assess synergy.

## Highest Single Agent / Highest Single Effect

The simplest model that one can assume for the response of drugs in combination is the Highest Single Agent model. This model predicts
that the result of treating with two drugs is the same as the highest response (or lowest viability) seen by treating with either drug
independently. Mathematically, this is equivalent to:

$$HSA((r_1,x_1), (r_2,x_2)) = \mbox{max}(r_1, r_2)$$

For viability values, this flips to a minimum.

Intuitively, this model can be interpreted as assuming that one compound is at the maximum possible effect, and the other is
treated as a potentiator, contributing little to the response itself, but allowing the maximum response of the first drug to
be increased. Practically, this case is not very often observed during in-vitro dose-response experiments, and the highest
single agent model is often a very weak baseline from which to compute synergy.

## Bliss Independence

Bliss Independence can be understood by making the assumption that cell death from treatment with a drugs is a stochastic process
with the probability of cell death being proportional to the response observed in the experiment. The model than assumes that the
cell death events from the two drugs are independent, for example because they occur through completely separate pathways. As such,
the model predicts that adding a second drug will kill the same fraction of cells as it kills on its own, and therefore the fractions
of cells remaining alive are caculated by multplying the fraction of cells alive after treatment with drug 1 in monotherapy,
with the fraction of cells alive after treatment with drug 2 in monotherapy. Mathematically, that works out to:

$$BLISS((v_1,x_1), (v_2,x_2)) = v_1 v_2$$

In response units this is:

$$BLISS((r_1,x_1), (r_2,x_2)) = r_1 + r_2 - r_1*r_2$$

This model is always going to be more strict that HSA (as long as response is between 0 and 1), and is usually a more practical assumption
to make when searching for drug synergy. Intuitively, one can think of it as modeling the case where the two drugs have separate mechanisms,
with synergy signifiying a biological interaction that makes them more effective than expected.

## Loewe Additivity

Loewe Additivity comes from a different assumption on what the effect of adding two drugs should be. While Bliss Independence assumes that the
drugs act independently, for example through different pathways, Loewe assumes that in the null case, adding $x_2$ concentration of a second drug
should lower the viability as if we added a proportional amount of the same drug, with that proportion caculated according to the relative efficacy
of the two drugs at the final combination viability. This proportinal relationship is defined implicity at each predicted value of $v_{loewe}
by the following formula:

$$ \frac{x_1}{X^{loewe}_1} + \frac{x_2}{X^{loewe}_2} = 1$$

where $ X^{loewe}_1 $ is the concentration of drug 1 required to achieve $v_{loewe}$ on its own, and similarly for $ X^{loewe}_2$ and drug 2.
Translating this to english, it assumes that we can lower the concentration of drug 1 needed to see the same effect by replacing the missing
dose with a similar amount of drug 2, adjusted for the difference in potency between the two drugs.

Practically, this formula is not very useful for estimating $v_{loewe}$ from actual dose-response data. However, if we assume that drug response
follows a Hill Curve model, we can define $y_{loewe}$ implicitly using the parameters $HS_{1}$, $EC50_{1}$,
and $E_{\infty,1}$, and $HS_{2}$, $EC50_{2}$, and $E_{\infty,2} by rearranging the Hill Curve relationship as follows:

$$ x = EC50 * (\frac{v-1}{v-E_{\infty}})^{\frac{1}{HS}}$$

We can then plug this relationship in to get an emplicit formula for $v_{loewe}$:

$$ \frac{x_1}{EC50_1 * (\frac{v_{loewe}-1}{v_{loewe}-E_{\infty,1}})^{\frac{1}{HS_1}}} + \frac{x_2}{EC50_2 * (\frac{v_{loewe}-1}{v_{loewe}-E_{\infty,2}})^{\frac{1}{HS_2}}} = 1$$

This formula can be solved numerically to find the value of $v_loewe$ for any two particular fitted curves.

<!-- TODO: write up combination Index -->

## ZIP

The Zero interaction Potency model was recently introduced with the goal of capturing the ideas behind both the Bliss and Loewe assumptions. As the name implies
the model assumes that the two drugs do not "potentiate" each other, meaning, that the only difference between the dose response curves of Drug 1 with and without
Drug 2 present is that the presence of Drug 2 changes the baseline response, without affecting the potency of Drug 1. The authors were then able to show that
the ZIP model can be derived from multiplying the two fitted Dose-Response curves together.
<!-- TODO: Finish me  -->


## Picking a Null Drug Combination Model

Given the fact that there is no universal consensus on which null model is correct in all cases, when analyzing drug combination data, a choice must be made
by the analyst. Ideally, this choice would be made according to reasonable assumptions about the drugs and their mechanisms of action. For example, for two compounds
which inhibit targets converging on the same pathway, the Loewe model may be most appropriate, whereas for drug combinations with completely unrelated mechanisms, Bliss
may be a more natural choice.

However, practical considerations may also limit your choices. For both the Loewe and ZIP approaches, one needs enough points to be measured to be able to fit Hill Curves
to the available data. For Loewe, this needs to be done only in monotherapy, while for ZIP, both monotherapy and combination data must have sufficient points to fit a curve.
On the other hand, both HSA and Bliss can be computed from the raw measurements of monotherapy viability, not requiring any models of the dose-response data to be fit.

In general, we would recommend using a model which makes stronger assumptions than HSA, which is the weakest of the presented models. If the number of tested
doses is low (<6), the Bliss model is probably the reference of choice, even though it is know to be quite strict. When possible to calculate, the ZIP
approach has advantages in a high-throughput setting, where it would be difficult to pick between Bliss and Loewe a-priori for each individual combination.


## Quantifying Synergy or Antagonism Compared to a Null Model

Once a null model is chosen, the expected combination viability or response is compared to the observed value, as mentioned above. For all methods, this can be done
using either a difference, or a ratio. In addition, the Loewe model directly facilitates calculating the Combination Index described above, and the ZIP model defines
the $\delta$ score for quantifying synergy. The main practical consideration when choosing how to compare the observations to the null is the scale on which results
will be interpreted or further analyzed. Taking the ratio of $v_c/v_{model}$, or using the Combination Index for Loewe leads to values that lie in ${0, \infty\]$
(with 1 as the reference for no syngergy or antagonism), similar to fold changes. On the other hand, both differences and the ZIP $\delta$-score lie on a bounded scale $\[-1,1\]$,
with 0 as the reference.

If the goal is simply to identify whether there was synergy or antagonism observed at a certain dose, the last step would be to visualize the results, and examine the extent
of deviation from the null model. For this, the scale chosen is a matter of preference. However, if the downstream goal is biomarker discovery using a summary of synergy for
each model tested with a particular combination, if the Combination Index or a ratio is used, it may be more appropriate to analyze the results on a log-scale, as otherwise
the range is unbalanced around the reference.

In practice, our preference is to use the absolute deviation from the Bliss predicted value for downstream analysis.


NB: Usually, the monotherapy response will be a subset of the full combination dose-response matrix, and therefore, will have been measured on the same doses. If this is not the case,
it may be necessary to fit a Hill Curve model even when using the Bliss or HSA approaches, to interpolate what the observed monotherapy viability should be at the doses used in the combination
experiment.

## Calculating Synergy Surfaces using a Treatment Response Experiment

In this section, we will work through analyzing the combination data from the NCI-Almanac dataset to calculate synergy surfaces at each dose for each combination of response. Here, the
TreatmentResponseExperiment aggregate API will allow us to expressively apply the modeling to every experiment in the data.


First, we will fit Hill Curve models to the monotherapy experiments in the data. This is required for calculating Loewe and ZIP based synergy scores, as well as whenever it is necessary to interpolate
between measured monotherapy doses to predict for the measured viability doses.

```{r}
treatmentResponse(NCI_ALMANAC_2017) |>
  subset(treatment2id == "") |>
  aggregate(
      assay="response",
      N=.N,
      by=c("treatment1id", "treatment1dose", "sampleid", "bio_rep")
  ) |>
  with(expr=hist(N))
```

First, we notice that there are replicate experiments for the monotherapy curves - the majority of these were replicates across plates, most probably so that monotherapy results could be plate matched to combination results.
We can make two choices for how to handle these replicates, either average across plates, or to match analysis by plate whenever possible. Ideally, we would prefer the latter, but in interest of computation time, we will demonstrate
the former approach.

Below, we will be first summarizing the replicate measurements using the mean viability before fitting dose-response curves, using the `aggregate` method. We then fit the curves using `logLogisticRegression`, and save the monotherapy fits back to the
PharmacoSet.

```{r extracting_nci_monotherapy_data}
nci <- NCI_ALMANAC_2017

# -- Fit the Hill curve model to monotherapy drugs and compute associated metrics

treatmentResponse(nci) |>
  subset(treatment2id == "") |>
  aggregate(
    assay="response",
    viability=mean(viability),
    by=c("treatment1id", "treatment1dose", "sampleid", "bio_rep")
  ) ->
  mono_raw

(treatmentResponse(nci)$mono_raw <- mono_raw)
```

```{r fitting_hill_curves_to_monotherapy}
mono_raw |>
  aggregate(
    {
      fit <- PharmacoGx::logLogisticRegression(treatment1dose, viability)
      ic50 <- PharmacoGx::computeIC50(treatment1dose, Hill_fit = fit)
      auc <- PharmacoGx::computeAUC(treatment1dose, Hill_fit = fit, area.type = "Fitted")
      list(
        HS = fit[["HS"]], E_inf = fit[["E_inf"]], EC50 = fit[["EC50"]],
        Rsq = as.numeric(unlist(attributes(fit))),
        auc = auc,
        ic50 = ic50
      )
    },
    by = c("treatment1id", "sampleid", "bio_rep"),
    enlist = FALSE,
    nthread = 4
  ) ->
  mono_profiles

# Store the results as TRE assays in out PharmacoSet
(treatmentResponse(nci)$mono_profiles <- mono_profiles)
```

We will now extract the combination data, and append the monotherapy Hill fits to the matrix, so that we can later use the fitted data from above to calculate expected combination viability.

```{r}
# -- Attach the Hill parameters from the monotherapy profiles to the combination data
# Extract the monotherapy fits
treatmentResponse(nci)$mono_profiles |>
  subset(, c("treatment1id", "sampleid", "bio_rep", "HS", "E_inf", "EC50")) ->
  mono_fits

treatmentResponse(nci)$response |>
  subset(treatment2id != "") ->
  combo_profiles


# Merge with the fits from the monotherapy experiments
combo_profiles |>
  merge(
    mono_fits,
    by = c("treatment1id", "sampleid", "bio_rep")
  ) |>
  merge(
    mono_fits,
    by.x = c("treatment2id", "sampleid", "bio_rep"),
    by.y = c("treatment1id", "sampleid", "bio_rep"),
    suffixes = c("_1", "_2")
  ) ->
  combo_profiles

setkeyv(combo_profiles, c("treatment1id", "treatment2id", "sampleid",
  "bio_rep"))
setcolorder(combo_profiles, c("treatment1id", "treatment2id", "sampleid",
  "bio_rep"))

# -- predict viability for each drug in our combination
# fix the scale of E_inf to be a proportion instead of a percent
combo_profiles[,
  c("E_inf_1", "E_inf_2") := .(E_inf_1 / 100, E_inf_2 / 100)
]
```

We then make predictions for each of the measured combination doses using fit corresponding parameters and the Hill Curve models.

```{r}
# predict viability at the combo doses from the Hill curves fit to monotherapy data
combo_profiles[,
  c("viability_1", "viability_2") := .(
    PharmacoGx:::.Hill(
      log10(treatment1dose),
      c(HS_1, E_inf_1, log10(EC50_1))
    ),
    PharmacoGx:::.Hill(
      log10(treatment2dose),
      c(HS_2, E_inf_2, log10(EC50_2))
    )
  ),
  by = c("treatment1id", "treatment2id", "treatment1dose", "treatment2dose",
    "sampleid", "bio_rep")
]
```



```{r}
# -- compute our drug synergy metrics
combo_profiles |>
  aggregate(
    HSA = min(viability_1, viability_2),
    Bliss = prod(viability_1, viability_2),
    Loewe_CI = (
      (treatment1dose /
        EC50_1 * ((1 - viability_1) / (viability_1 - E_inf_1))^(1 / HS_1)
      ) +
        (treatment2dose /
          EC50_2 * ((1 - viability_2) / (viability_2 - E_inf_2))^(1 / HS_2)
        )
    ),
    ZIP = {
      dose_ratio1 <- (treatment1dose / EC50_1)
      dose_ratio2 <- (treatment2dose / EC50_2)
      ZIP1 <- 1 / (1 + dose_ratio1^HS_1)
      ZIP2 <- 1 / (1 + dose_ratio2^HS_2)
      ZIP1 * ZIP2
    },
    viability_1 = viability_1,
    viability_2 = viability_2,
    viability = viability / 100,
    by = c("treatment1id", "treatment2id", "treatment1dose", "treatment2dose",
      "sampleid", "bio_rep")
  ) -> combo_profiles1

# -- compute combination index and score
combo_profiles1 |>
  aggregate2(
    HSA_CI = viability / HSA,
    HSA_score = HSA - viability,
    Bliss_CI = viability / Bliss,
    Bliss_score = Bliss - viability,
    ZIP_CI = viability / ZIP,
    ZIP_score = ZIP - viability,
    Loewe_CI = Loewe_CI,
    viability = viability,
    viability_1 = viability_1,
    viability_2 = viability_2,
    by = c("treatment1id", "treatment2id", "treatment1dose", "treatment2dose",
      "sampleid", "bio_rep")
  ) -> combo_profiles2

```



Once we have a measure of synergy calculated for each dose combination in a particular experiment, we often would like to visualize the whole surface of drug-dose combinations to understand
how synergy depends on dosage.

Below, we plot the Bliss score for an antagonistic combination of drugs, Mitotane and Paclitaxel, on the A-549 cell line. If we recall the formula for the Bliss score above, we took $v_{model} - v_c$, meaning that
in this case, negative numbers indicate antagonism, as there is more viability observed than expected.

```{r}
library(ggplot2)
ggplot(combo_profiles2[treatment1id == "Mitotane" & treatment2id == "Paclitaxel" & sampleid == "A-549"], aes(treatment1dose, treatment2dose, fill = Bliss_score)) +
  geom_tile() +
  scale_x_log10() +
  scale_y_log10() + xlab("Mitotane") + ylab("Paclitaxel")

```


### Summarizing Synergy Matrices into Single Values

Often, we will want to summarize a whole synergy surface into a single synergy score for a drug combination per cell-line, for example, if we want to discover biomarkers of synergy. There are several methods that
this can be done, the most common of which is taking the average value of your score matrix for the combination. If your doses are equally spaced (on the log scale), this will give a measure of Volume Under the Surface.

For some experiments, you may want to be a bit more careful, and not select the average of the whole surface. For example, in the experiment above, we see very strong antagonism when both doses of the drugs are high.
However, this may not be a very interesting regime, as often one of the goals of drug combination therapy is to limit the dose of any single drug used to reduce associated toxicities. Therefore, an option could be to
summarize only over a dose-range of interest.

If you find yourself in a situation where synergy is observed only in a narrow dose range, the most extreme deviation from the reference (0 or 1, depending on use of additive or fold-change metrics) may instead be more
appropriate.

Below, we will summarize the combination profiles we have calculated into a Mean Bliss Score per experiment.


```{r}

mean_bliss_score <- combo_profiles2[,
  .(Mean_Bliss = mean(Bliss_score)),
  .(treatment1id, treatment2id, sampleid)
]


```

# Biomarker Discovery:

## Monotherapy response



## Combination Synergy

```{r}
## Create a matrix of drug combo x cell lines.
synergy_summaries <- reshape2::dcast(
    mean_bliss_score,
    treatment1id + treatment2id ~ sampleid
)

rownames(synergy_summaries) <- paste(
    synergy_summaries$treatment1id,
    synergy_summaries$treatment2id,
    sep="_+_"
  )

synergy_summaries <- data.matrix(synergy_summaries[, -c(1:2)])

```

```{r}
gene_exp_sigs <- drugSensitivitySig(NCI_ALMANAC_2017,
    mDataType = "rnaseq.comp",
    sProfiles = synergy_summaries,
    drugs = "Mitotane_+_Paclitaxel",
    modeling.method="pearson",
    nthread=2
)
plot(gene_exp_sigs)
```


----

# Introduction to Resources for Biomarker Validation


----

# References

<div id="refs"></div>

# SessionInfo

```{r session_info, include=FALSE}
sessionInfo()
```